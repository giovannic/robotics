#pragma config(Sensor, S1,     sonar,               sensorSONAR)
#pragma config(Sensor, S2,     bump,                sensorTouch)
#pragma config(Motor,  motorA,          left,          tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorB,          right,         tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          sonarMotor,    tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int sonarOffset = 4;

const float ENC_P_CM = 21.157;
const int drive_power = 30;
bool extend = false;
const int distance = 300;
const int extension = 300;

void turnOut()
{
  int boundary = 0;
  int originWallDistance = 63;

  nSyncedMotors = synchAB;
  nSyncedTurnRatio = -100;
  motor[motorA] = drive_power;

  while(abs((SensorValue[sonar] - sonarOffset) - originWallDistance) > boundary)
    ;

  motor[motorA] = 0;
}

void sonarForward()
{
  motor[motorC] = 20;
  while(nMotorEncoder[motorC] < 90)
    ;
  motor[motorC] = 0;
}

void sonarLeft()
{
  motor[motorC] = -20;
  while(nMotorEncoder[motorC] > 0)
    ;
  motor[motorC] = 0;
}

void follow_wall()
{
  sonarLeft();
  const int wall_follow_distance = 20;
  const float damper = 0.5;
  float balance = 0;

  nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
  motor[motorA] = drive_power;
  motor[motorB] = drive_power;

  float lineStart = nMotorEncoder[motorA];
  float encoderLimit = ENC_P_CM*distance;

  while((nMotorEncoder[motorA] - lineStart) < encoderLimit/2)
  {
    balance = damper*(SensorValue[S1] - wall_follow_distance);
    if (balance > 0)
    {
      motor[motorA] = drive_power;
      motor[motorB] = drive_power + balance;
    } else {
      motor[motorA] = drive_power - balance;
      motor[motorB] = drive_power;
    }
  }

  /*check for an extended ride*/
  sonarForward();
  if (SensorValue[sonar] > 100 && extend)
  {
    encoderLimit += extension;
  }
  sonarLeft();

  while((nMotorEncoder[motorA] - lineStart) < encoderLimit)
  {
    balance = damper*(SensorValue[S1] - wall_follow_distance);
    if (balance > 0)
    {
      motor[motorA] = drive_power;
      motor[motorB] = drive_power + balance;
    } else {
      motor[motorA] = drive_power - balance;
      motor[motorB] = drive_power;
    }
  }

  sonarForward();
}

void driveToBackWall()
{
  //Drive forwards till the sonar gives a reading of 21.

  nSyncedMotors = synchAB;
  nSyncedTurnRatio = 100;
  motor[motorA] = 30;
  while(SensorValue(sonar) > 21 - sonarOffset)
    ;
  motor[motorA] = 0;

}

void chamberAdjust()
{
  //Sonar look left + take reading.
  nMotorEncoder[motorC] = 0;
  motor[motorC] = 5;
  while(nMotorEncoder[motorC] < 90)
    ;
  motor[motorC] = 0;
  int leftReading = SensorValue(sonar);
  nxtDisplayCenteredTextLine(1, "LR: %d", leftReading);

  //Sonar look right + take reading.
  motor[motorC] = -5;
  while(nMotorEncoder[motorC] > -90)
    ;
  motor[motorC] = 0;
  int rightReading = SensorValue(sonar);
  nxtDisplayCenteredTextLine(2, "RR: %d", rightReading);


  wait1Msec(5000);
  //Recenter sonar
  motor[motorC] = 5;
  while(nMotorEncoder[motorC] < 0)
    ;
  motor[motorC] = 0;
  //Adjust the position of the robot so that the left reading = right reading.
  if(leftReading > rightReading)
  {
    turnRadiansClockwise(PI/2);
    nSyncedMotors = synchAB;
    nSyncedTurnRatio = 100;
    motor[motorA] = 5;
    while( SensorValue(sonar) > 21 - sonarOffset)
      ;
    motor[motorA] = 0;
    turnRadiansClockwise(-PI/2);
  }
  else if(leftReading < rightReading)
  {
    turnRadiansClockwise(-PI/2);
    nSyncedMotors = synchAB;
    nSyncedTurnRatio = 100;
    motor[motorA] = 5;
    while( SensorValue(sonar) > 21 - sonarOffset)
      ;
    motor[motorA] = 0;
    turnRadiansClockwise(PI/2);
  }

}

void beep()
{
  //beep when done.
  PlayImmediateTone(780, 100);
}

task main()
{

  /*initialise encoders*/
  nMotorEncoder[motorA] = 0;
  nMotorEncoder[motorB] = 0;
  nMotorEncoder[motorC] = 0;

  turnOut();
  follow_wall();
  //chamberAdjust();

  extend = true;

  turnOut();
  follow_wall();
  //chamberAdjust();

  turnOut();
  follow_wall();
  //chamberAdjust();
}
