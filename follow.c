#pragma config(Sensor, S1,     sonar,               sensorSONAR)
#pragma config(Sensor, S2,     bump,                sensorTouch)
#pragma config(Motor,  motorA,          left,          tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorB,          right,         tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          sonarMotor,    tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//
const float ENC_P_CM = 21.157;
const int drive_power = 50;
const int wall_distance = 20;
const float damper = 0.5;

void follow_wall(int distance)
{

  float lastMotorValue = 0;
  float distanceMoved = 0;
  float currentDistance = 0;
  float balance = 0;

  nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
  motor[motorA] = drive_power;
  motor[motorB] = drive_power;

  float lineStart = nMotorEncoder[motorA];
  float  encoderLimit = ENC_P_CM*distance;

  while((nMotorEncoder[motorA] - lineStart) < encoderLimit)
  {
    balance = damper*(SensorValue[S1] - wall_distance);
    if (balance > 0)
    {
      motor[motorA] = drive_power + balance;
      motor[motorB] = drive_power;
    } else {
      motor[motorA] = drive_power;
      motor[motorB] = drive_power - balance;
    }
  }

}

task main()
{

  //Turn the sonar left.
  nMotorEncoder[motorC] = 0;
  motor[motorC] = 20;
  while(nMotorEncoder[motorC] < 90)
    ;

  follow_wall(40);


  //fix and return
  nMotorEncoder[motorC] = 0;
  motor[motorC] = -20;
  while(nMotorEncoder[motorC] > 0)
    ;
  motor[motorC] = 0;

}
