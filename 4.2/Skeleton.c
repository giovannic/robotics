#pragma config(Sensor, S1,     sonar,               sensorSONAR)
#pragma config(Sensor, S2,     light,               sensorLightActive)
#pragma config(Motor,  motorA,          left,          tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorB,          right,         tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          sonarMotor,    tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "circularScan.c"
#include "Utils.c"

int first;
int second;
int third;

int sonarOffset = 4;

const float ENC_P_CM = 21.157;

/* Global to fix memory error. */
loc_sig scan;

void sonarTo(int degrees)
{
  degrees = - degrees;
  const int speed = 20;
  int difference = nMotorEncoder[motorC] - degrees;

  if (difference < 0)
  {
    motor[motorC] = speed;
    while(nMotorEncoder[motorC] < degrees)
      ;
  } else {
    motor[motorC] = -speed;
    while(nMotorEncoder[motorC] > degrees)
      ;
  }
  motor[motorC] = 0;
  wait1Msec(500);

}

void turnOut()
{
  int boundary = 1;
  int originWallDistance = 55;
  const int drive_power = 20;

  int lastVal = 0;

  nMotorEncoder[motorA] = 0;
  nSyncedMotors = synchAB;
  nSyncedTurnRatio = -100;
  motor[motorA] = drive_power;

  while(abs(SensorValue[sonar] - originWallDistance) > boundary)
  {
    if(nMotorEncoder[motorA] / 360 != lastVal)
    {
      lastVal = nMotorEncoder[motorA] / 360;
      boundary++;
    }
  }

  motor[motorA] = 0;
}


void getIntoCorridor()
{
  /*
  const int distanceToWall = 55;

  int result = -1;
  int bestDifference = -1;
  int currentDifference = 0;
  //Scan 360 and work out which array element is the largest sonar reading.

  //Make this so it rotates the robot!
  circularScan(scan);

  for(int i = 0 ; i < NO_BINS ; i++)
  {
    currentDifference = abs(scan.sig[i] - sonarOffset - distanceToWall);
    if((currentDifference < bestDifference) || bestDifference == -1)
    {
      result = i;
      bestDifference = currentDifference;
    }
  }

  nxtDisplayCenteredTextLine(1, "ArrElt: %d", result);
  wait1Msec(1000);

  //Rotate so that you face that way.
  float turnAngle = (result / 180.0)*PI;

  nxtDisplayCenteredTextLine(2, "TurnAngle: %f", turnAngle);
  wait1Msec(1000);

  turnRadiansClockwise(turnAngle); //minus removed
*/
  turnOut();
  wait1Msec(500);
  nSyncedMotors = synchAB;
  nSyncedTurnRatio = 100;
  motor[motorA] = 30;
  //motor[motorA] = 70;

  while(SensorValue[sonar] > 21 - 2) //-sonarOffset
    ;

  motor[motorA] = 0;

  //Scan 360 and work out which array element is the largest sonar reading.
  //Rotate so that you face that way.
  //Drive until you are 21 away from the wall infront (allow for sonar wheelbase offset)
}

int calculateCurrentWaypoint()
{
  int waypoint = 0;

  //Turn the sonar right.
  sonarTo(90);

  if (SensorValue[sonar] < 50)
  {
    //fix and return
    sonarTo(0);
    return 1;
  }

  //Turn the sonar left.
  sonarTo(-90);

  if (SensorValue[sonar] < 50)
  {
    waypoint = 3;
  } else {
    waypoint = 2;
  }

  //fix and return
  sonarTo(0);
  return waypoint;
}

void corridorTurn(int currentWaypoint, int destinationWaypoint)
{
  //Turn based on arguments.
  //Face sonar to the correct wall.

  nxtDisplayCenteredTextLine(4, "from: %d", currentWaypoint);
  nxtDisplayCenteredTextLine(5, "to: %d", destinationWaypoint);
  //wait1Msec(1000);

  float a = 0;
  switch(currentWaypoint)
  {
    case 1:
      a = PI/2;
      break;
    case 2:
      a = (destinationWaypoint == 1) ? -PI/2 : PI/2;
      break;
    case 3:
      a = -PI/2;
      break;
  }
  turnRadiansClockwise(a);
}

void follow_outer_wall(int from)
{
  int balance = 0;
  int reading = 0;

  int wall_follow_distance = 20;
  const float damper = 3; //3
  const int drive_power = 50; //50
  const int base = 7;

  nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
  motor[motorA] = drive_power;
  motor[motorB] = drive_power;

  if(SensorValue[S1] < 18 || SensorValue[S1] > 22)
  {
    //wall_follow_distance = SensorValue[S1];
  }

  while(SensorValue[S2] < 30) //<30
  {
    reading = SensorValue[S1];
    if(reading < 100)
    {
      balance = damper*(SensorValue[S1] - wall_follow_distance);
    } else {
      if (balance < 0)
      {
        balance = -base;
      } else {
        balance = base;
      }
    }

    if(from == 3)
    {
      motor[motorA] = drive_power - balance;
      motor[motorB] = drive_power + balance;
    }
    else //from == 2
    {
      motor[motorA] = drive_power + balance;
      motor[motorB] = drive_power - balance;
    }

  }

  motor[motorA] = 0;
  motor[motorB] = 0;

  nxtDisplayCenteredTextLine(1, "End Of Follow");
  wait1Msec(500);


}

void follow_inner_wall()
{
  nxtDisplayCenteredTextLine(1, "INNER WALL.");
  wait1Msec(500);

  int balance = 0;
  int reading = 0;

  int wall_follow_distance = 20;
  const float damper = 3;
  const int drive_power = 30;
  const int base = 7;

  /*nSyncedMotors = synchAB;
  nMotorEncoder[motorA] = 0;
  motor[motorA] = 20;
  while(nMotorEncoder[motorA] < 500)
  {


  }

  motor[motorA] = 0;
  nxtDisplayCenteredTextLine(1, "Wall Lineup");
  wait1Msec(1000);*/

  //nMotorEncoder[motorA] = 0;
  //nMotorEncoder[motorB] = 0;

    nSyncedMotors = synchNone;
  nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;

    nxtDisplayCenteredTextLine(1, "Aligned.");
  //wait1Msec(500);

    nxtDisplayCenteredTextLine(1, "A: %d B: %d.", nMotorEncoder[motorA], nMotorEncoder[motorB]);
  //wait1Msec(500);

  nMotorEncoder[motorA] = nMotorEncoder[motorA] - nMotorEncoder[motorA];
  nMotorEncoder[motorB] =   nMotorEncoder[motorB] -   nMotorEncoder[motorB];

      nxtDisplayCenteredTextLine(2, "A: %d B: %d.", nMotorEncoder[motorA], nMotorEncoder[motorB]);
  //wait1Msec(500);

  motor[motorA] = drive_power;
  motor[motorB] = drive_power;

  wall_follow_distance = SensorValue[S1];

  int maStart = nMotorEncoder[motorA];
  int mbStart = nMotorEncoder[motorB];

  int aDiff = nMotorEncoder[motorA] - maStart;
  int bDiff = nMotorEncoder[motorB] - mbStart;

  while((0.5*(aDiff + bDiff)) < 5400)
  {
    reading = SensorValue[S1];
    nxtDisplayCenteredTextLine(4, "A: %d", aDiff);
    nxtDisplayCenteredTextLine(5, "B: %d", bDiff);

    if(reading < 100)
    {
      balance = damper*(SensorValue[S1] - wall_follow_distance);
    } else {
      if (balance < 0)
      {
        balance = -base;
      } else {
        balance = base;
      }
    }
    motor[motorA] = drive_power + balance;
    motor[motorB] = drive_power - balance;
    aDiff = nMotorEncoder[motorA] - maStart;
    bDiff = nMotorEncoder[motorB] - mbStart;
  }


    motor[motorA] = 0;
  motor[motorB] = 0;
  nxtDisplayCenteredTextLine(1, "End.");
  wait1Msec(500);


}

void downCorridor(int from, int to)
{
  //If the destination is waypoint 2 we need to train the odometry to drive
  //the correct distance whilst wall following.

  //Otherwise we need to wall follow and occasionaly shoot the sonar forwards
  //to gauage our depth from the wall infront. We want to stop at 21 from the
  //wall.

  nSyncedMotors = synchNone;

  switch(from)
  {
    case 1:
      sonarTo(90);
      follow_inner_wall();
      sonarTo(0);
      break;
    case 2:
      sonarTo(90);
      follow_outer_wall(2);
      sonarTo(0);
      break;
    case 3:
      sonarTo(-90);
      follow_outer_wall(3);
      sonarTo(0);
      break;
  }
}

void turnToWaypoint(int previous, int dest)
{
  //Rotate to face the waypoint, for 1 and 3 this is dependent only on the
  //destination whereas for waypoint 2 we need to know where we came from.
  //Turn based on arguments.
  //Face sonar to the correct wall.
  float a = 0;
  switch(dest)
  {
    case 1:
      a = -PI/2;
      break;
    case 2:
      switch(previous)
      {
        case 1:
          a = PI/2;
          break;
        case 3:
          a = -PI/2;
          break;
      }
    case 3:
      a = PI/2;
      break;
  }
  turnRadiansClockwise(a);
}

void driveToBackWall()
{
  //Drive forwards till the sonar gives a reading of 21.

  nSyncedMotors = synchAB;
  nSyncedTurnRatio = 100;
  motor[motorA] = 30;
  while(SensorValue(sonar) > 21 - sonarOffset)
    ;
  motor[motorA] = 0;

}

void chamberAdjust()
{
  //Sonar look left + take reading.
  sonarTo(90);
  int rightReading = SensorValue(sonar);
  nxtDisplayCenteredTextLine(1, "RR: %d", rightReading);

  //Sonar look right + take reading.
  sonarTo(-90);
  int leftReading = SensorValue(sonar);
  nxtDisplayCenteredTextLine(2, "LR: %d", leftReading);


  wait1Msec(500);
  //Recenter sonar
  sonarTo(0);
  //Adjust the position of the robot so that the left reading = right reading.
  if(leftReading > rightReading)
  {
    turnRadiansClockwise(PI/2);
    nSyncedMotors = synchAB;
    nSyncedTurnRatio = 100;
    motor[motorA] = 10; //5
    while(SensorValue(sonar) > 21 - sonarOffset)
      ;
    motor[motorA] = 0;
    turnRadiansClockwise(-PI/2);
  }
  else if(leftReading < rightReading)
  {
    turnRadiansClockwise(-PI/2);
    nSyncedMotors = synchAB;
    nSyncedTurnRatio = 100;
    motor[motorA] = 10; //5
    while( SensorValue(sonar) > 21 - sonarOffset)
      ;
    motor[motorA] = 0;
    turnRadiansClockwise(PI/2);
  }

}

void beep()
{
  //beep when done.
  PlayTone(523,40);
}


task main()
{

  nMotorEncoder[motorC] = 0;

	getIntoCorridor();
	int currentWaypoint = calculateCurrentWaypoint();

	nxtDisplayCenteredTextLine(3, "WP: %d", currentWaypoint);
  //wait1Msec(3000);

	if(currentWaypoint == 1)
	{
		first = 2;
		second = 3;
		third = 1;
	}
	else if(currentWaypoint == 2)
	{
		first = 3;
		second = 1;
		third = 2;
	}
	else //currentWaypoint == 3
	{
		first = 1;
		second = 2;
		third = 3;
	}

	// First
	corridorTurn(currentWaypoint, first);
	downCorridor(currentWaypoint, first);
  nxtDisplayCenteredTextLine(1, "About To Turn");
	//wait1Msec(3000);

	turnToWaypoint(currentWaypoint, first);
	nxtDisplayCenteredTextLine(1, "Turned.");
	//wait1Msec(3000);

	driveToBackWall();
	chamberAdjust();
	beep();
  // End First

	wait1Msec(500);

	// Second
	currentWaypoint = first;
	getIntoCorridor();
	corridorTurn(currentWaypoint, second);
	downCorridor(currentWaypoint, second);
	turnToWaypoint(currentWaypoint, second);
	driveToBackWall();
	chamberAdjust();
	beep();

	// End Second

		wait1Msec(500);

	// Third
	currentWaypoint = second;
	getIntoCorridor();
	corridorTurn(currentWaypoint, third);
	downCorridor(currentWaypoint, third);
	turnToWaypoint(currentWaypoint, third);
	driveToBackWall();
	chamberAdjust();
	beep();

	// End Third

	wait1Msec(500);
}
